package types

import (
	"homework/probability/utils"

	"fyne.io/fyne/v2"
)

var ThemeIcons = map[string]fyne.Resource {
	"Множества": utils.ThemeIconsMustLoad("asserts/icons/icons8-lock-100.png"),
	"Элементы теории высказываний": utils.ThemeIconsMustLoad("asserts/icons/icons8-epistemology-64.png"),
	"Комбинаторика": utils.ThemeIconsMustLoad("asserts/icons/icons8-color-filter-96.png"),
	"Теория графов": utils.ThemeIconsMustLoad("asserts/icons/icons8-graphs-64.png"),
	"Изоморфизм графов": utils.ThemeIconsMustLoad("asserts/icons/icons8-graphs-64.png"),
	"Планарные графы": utils.ThemeIconsMustLoad("asserts/icons/icons8-graphs-64.png"),
	"Деревья": utils.ThemeIconsMustLoad("asserts/icons/icons8-tree-64.png"),
	"Алгоритм Дейкстры": utils.ThemeIconsMustLoad("asserts/icons/icons8-algorithm-100.png"),
}

var Themes = []string{
	"Множества",
	"Элементы теории высказываний",
	"Комбинаторика",
	"Теория графов",
	"Изоморфизм графов",
	"Планарные графы",
	"Деревья",
	"Алгоритм Дейкстры",
}

type ProbabilityData struct {
	Title              string
	Theory             string
	FormulaPath        string
	FormulaDescription string
	ExampleText        string
	ExampleImage       string
	Hint               string
	SolutionText       string
}

type MainService interface {
	Calculate(n, m int) (float64, error)
}

func ThemeSwitcher(theme string) ProbabilityData {
	switch theme {
	case "Множества":
		return ProbabilityData{
			Title:              "Множества",
			Theory:             "Множество — это набор разных (уникальных) объектов, объединённых по какому-то признаку.",
			//ExampleImage:
			ExampleText: "В классе 30 учеников. Из них:\n"+
			"18 занимаются математикой,\n"+
			"12 — программированием,\n"+
			"5 — и математикой, и программированием.\n"+
			"Вопрос: Сколько учеников не занимаются ни математикой, ни программированием?",
			Hint: "1.Воспользуйтесь формулой включений-исключений для двух множеств(чтобы найти тех, что занимаются хотя бы 1-им предметом) :\n"+
			"|A ∪ B| = | A | + | B | - |A ∩ B|\n" + 
			"2.Найдите число тех, которые ничем не занимаются.",
			SolutionText:       "В пересечении — 5 человек.\n"+
			"Только математика: 18−5=13.\n"+
			"Только программирование: 12−5=7.\n"+
			"Ничего:  30−(13+5+7)=5.", 
		}

	case "Элементы теории высказываний":
		return ProbabilityData{
			Title:              "Элементы теории высказываний",
			Theory:             "Высказывание — это утверждение, которое может быть либо истинным, либо ложным.",
			FormulaDescription: "Основные логические операции:",
			ExampleImage:       "asserts/images/элементы_теории_выск.png",
			ExampleText: "Найти все наборы значений A, B, C ∈ {0, 1}, при которых логическое выражение (A ∨ B) → (¬C ∧ A) принимает значение 1 (истина).",
			Hint: "Порядок выполнения операций:\n"+
			"1. Скобки,\n"+
			"2. Отрицание (¬),\n"+ 
			"3. Конъюнкция (∧),\n"+
			"4. Дизъюнкция (∨),\n"+
			"5. Импликация (→)",
			SolutionText: "Решение примера:\n" +
				"1. Перебираем все возможные комбинации A, B, C ∈ {0,1}.\n" +
				"2. Рассматриваем выражение (A ∨ B) → (¬C ∧ A).\n" +
				"3. Получаем следующие результаты:\n" +
				"- A = 1, B = 0, C = 0: 1 → (1 ∧ 1) = 1\n" +
				"- A = 0, B = 0, C = 1: 0 → (1 ∧ 0) = 1\n" +
				"- A = 1, B = 1, C = 1: 1 → (0 ∧ 1) = 0 (ложь)\n" +
				"Итог: выбираем все комбинации, где выражение истинно.",
		}

	case "Комбинаторика":
		return ProbabilityData{
			Title:              "Комбинаторика",
			Theory:             "Комбинаторика — это это раздел математики, в котором рассматриваются задачи, связанные с подсчетом количества комбинаций при определенных условиях.",
			//ExampleImage:
			ExampleText: "1. Правила суммы и произведения.\n"+
			"Задача:\n"+
			"В кафе есть 3 вида пирожных и 5 видов напитков. Сколько вариантов заказа из одного пирожного и одного напитка?\n"+
			"\n"+
			"2. Перестановки (без повторений)\n"+
			"Задача:\n"+
			"Сколько способов расставить 4 книги на полке?\n"+
			"\n"+
			"3. Перестановки с повторениями\n"+
			"Задача:\n"+
			"Сколько различных слов можно составить из букв слова МАТЕМАТИКА?\n"+
			"\n"+
			"4. Размещения (без повторений)\n"+
			"Задача:\n"+
			"В конкурсе 10 участников. Сколькими способами можно распределить 1-е, 2-е и 3-е места?\n"+
			"\n"+
			"5. Размещения с повторениями\n"+
			"Задача:\n"+
			"Сколько 4-значных кодов можно составить из цифр 0-9, если цифры могут повторяться?\n"+
			"\n"+
			"6. Сочетания (без повторений)\n"+
			"Задача:\n"+
			"Сколькими способами можно выбрать 3 дежурных из 10 человек?\n"+
			"\n"+
			"7. Сочетания с повторениями\n"+
			"Задача:\n"+
			"В магазине есть 5 видов печенья. Сколько способов купить 3 печенья, если можно брать несколько одинаковых?\n"+
			"\n"+
			"8. Бином Ньютона\n"+
			"Задача:\n"+
			"Раскройте скобки: (x+2)^4"+
			"\n"+
			"9. Треугольник Паскаля\n"+
			"Задача:\n"+
			"Найдите коэффициент при x^2 в разложении (1+x)^5",
			Hint:"9.Треугольник Паскаля:\n"+
			"Коэффициенты берутся из 5-й строки треугольника Паскаля: 1, 5, 10, 10, 5, 1.",
			SolutionText:"1. Правила суммы и произведения.\n"+
			"3 × 5=15 вариантов.\n"+
			"\n"+
			"2. Перестановки (без повторений)\n"+
			"4!=24 способа.\n"+
			"\n"+
			"3. Перестановки с повторениями\n"+
			" 10!/(2! × 3! × 2!) = 151200.\n"+
			"\n"+
			"4. Размещения (без повторений)\n"+
			"10 × 9 × 8 = 720.\n"+
			"\n"+
			"5. Размещения с повторениями\n"+
			"10^4 = 10000 кодов.\n"+
			"\n"+
			"6. Сочетания (без повторений)\n"+
			"10!/(3! × (10 - 3)!) = 120.\n"+
			"\n"+
			"7. Сочетания с повторениями\n"+
			"Ответ: 35\n"+
			"\n"+
			"8. Бином Ньютона\n"+
			"(x^4) + (8x^3) + (24x^2) + 32x+16\n"+
			"\n"+
			"9. Треугольник Паскаля\n"+
			"Коэффициент 10.\n",	
		}

	case "Теория графов":
		return ProbabilityData{
			Title:              "Теория графов",
			Theory:             "Граф - совокупность точек(вершин), некоторые из которых, а может быть и все, могут быть соединены линиями(ребрами).",
			//ExampleImage:
			ExampleText: "В городе есть 7 мостов, соединяющих острова и берега реки следующим образом:\n"+
			"Остров A соединён с берегами B и C двумя мостами каждый.\n"+
			"Острова A и D соединены одним мостом.\n"+
			"Остров D соединён с берегом C одним мостом.\n"+
			"Вопрос: Можно ли совершить прогулку, пройдя по каждому мосту ровно один раз и вернувшись в исходную точку?\n",
			Hint: "Моделирование графа:\n"+
			"Вершины = участки суши (A, B, C, D).\n"+
			"Рёбра = мосты.\n"+
			"\n"+
			"Критерий Эйлерова цикла:\n"+
			"Граф должен быть связным.\n"+
			"Все вершины должны иметь чётные степени.\n"+
			"\n"+
			"Степени вершин:\n"+
			"\n"+
			"Задача:\n"+
			"Посчитайте, сколько рёбер (мостов) соединяется с каждой вершиной.",
			SolutionText: "Построим граф:\n"+
			"Степень A: 2 (B) + 2 (C) + 1 (D) = 5.\n"+
			"Степень B: 2 (A) = 2.\n"+
			"Степень C: 2 (A) + 1 (D) = 3.\n"+
			"Степень D: 1 (A) + 1 (C) = 2.\n"+
			"\n"+
			"Вершины A (5) и C (3) имеют нечётные степени.\n"+
			"По теореме Эйлера, цикл существует только если все степени чётные.\n"+
			"\n"+
			"Ответ: Нет, такой маршрут невозможен (так как у графа две вершины с нечётными степенями).",
		}

	case "Изоморфизм графов":
		return ProbabilityData{
			Title:  "Изоморфизм графов",
			Theory:  "Изоморфизм - переименование вершин и ребер графа G1, которое сохранияет отношение инцидентности\n"+
			"Инцидентность — это отношение между вершиной и ребром, при котором:\n"+
			"Вершина называется инцидентной ребру, если она является одним из его концов.\n"+
			"Ребро называется инцидентным вершине, если оно соединяет эту вершину с другой.",
			//ExampleImage:
			ExampleText: "Условие:\n"+
			"Даны два графа G1 и G2. Определите, являются ли они изоморфными. Если да, приведите соответствие вершин.\n"+
			"\n"+
			"Граф G1:\n"+
			"Вершины: A,B,C,D \n"+
			"Рёбра: AB,BC,CD,DA,AC \n"+
			"\n"+
			"Граф G2: \n"+
			"Вершины: 1,2,3,4\n"+
			"Рёбра: 12,23,34,41,13\n",
			Hint: "Определение изоморфизма:\n"+
			"Графы изоморфны, если существует взаимно однозначное соответствие вершин, сохраняющее смежность.\n"+
			"\n"+
			"Критерии:\n"+
			"Одинаковое число вершин и рёбер.\n"+
			"Совпадающие степени всех вершин.\n"+
			"Одинаковая структура связей (проверяется перебором).\n"+
			"\n"+
			"Совет:\n"+
			"Попробуйте «переименовать» вершины одного графа, чтобы получить второй.\n",
			SolutionText: "1. Проверка базовых свойств:\n"+

			"Оба графа имеют по 4 вершины и 5 рёбер.\n"+
			"Степени вершин:\n"+
			"В G1: A(3),B(2),C(3),D(2).\n"+
			"В G2: 1(3),2(2),3(3),4(2).\n"+
			"Совпадают!\n"+
			"\n"+
			"2. Поиск соответствия вершин:\n"+
			"Попробуем сопоставить вершины с одинаковыми степенями:\n"+
			"A(степень 3) ↔ 1(степень 3).\n"+
			"C(степень 3) ↔ 3(степень 3).\n"+
			"B (степень 2) ↔ 2 (степень 2).\n"+
			"D (степень 2) ↔ 4 (степень 2).\n"+
			"Проверка рёбер:\n"+
			"В G1: AB ↔ 12, BC ↔ 23, CD ↔ 34, DA ↔ 41, AC ↔ 13.\n"+
			"Все рёбра сохраняются!\n"+
			"\n"+
			"3. Изоморфное соответствие:\n"+
			"A ↔ 1,\n"+
			"B ↔ 2,\n"+
			"C ↔ 3,\n"+ 
			"D ↔ 4.\n"+
			"\n"+
			"\n"+
			"Ответ:\n"+
			"Да, графы изоморфны. Соответствие вершин:\n"+
			"A ↔ 1,\n"+
			"B ↔ 2,\n"+
			"C ↔ 3,\n"+ 
			"D ↔ 4.\n",
		}

	case "Планарные графы":
		return ProbabilityData{
			Title:  "Планарные графы",
			Theory: "Планарный граф — это такой граф, который можно нарисовать на плоскости без пересечений рёбер.",
			//ExampleImage:
			ExampleText: "Условие:\n"+
			"Дан граф G с p=6 вершинами и q=12 рёбрами.\n"+
			"Вопрос: Можно ли нарисовать его на плоскости без пересечений рёбер?\n"+
			"\n"+
			"Дополнительные данные:\n"+
			"В графе нет петель и кратных рёбер.\n"+
			"Все вершины имеют степень не меньше 3.\n",
			Hint: "Критерий планарности:\n"+
			"Для связного планарного графа с p вершинами и q рёбрами должно выполняться: q ≤ 3p − 6\n"+
			"(Если граф не содержит треугольников, то q ≤ 2p − 4.)\n"+
			"\n"+
			"Проверка на полные графы:\n"+
			"Если граф содержит подграф, гомеоморфный K(5) (5 вершин, 10 рёбер) или K(3,3)(6 вершин, 9 рёбер), он непланарен.\n",
			SolutionText: "Проверяем неравенство планарности:\n"+
			"Подставляем p=6, q=12:\n"+
			"12≤3⋅6−6\n"+
			"12≤12\n"+
			"Равенство выполняется, но это не гарантирует планарность.\n"+
			"\n"+
			"Анализируем структуру графа:\n"+
			"У графа q=12 рёбер, что равно максимальному количеству рёбер для планарного графа с p=6.\n"+
			"Однако, если все вершины имеют степень ≥3, граф, скорее всего, содержит подграф K (3,3)(непланарен).\n"+
			"\n"+
			"Вывод:\n"+
			"Граф непланарен, так как:\n"+
			"Он достигает верхней границы рёбер (q = 3p − 6),\n"+
			"И при этом содержит подграф, гомеоморфный K (3,3)\n",
		}


	case "Деревья":
		return ProbabilityData{
			Title:        "Деревья",
			Theory:       "Граф G называется ациклическим или лесом, если в нем нет циклов. Ациклический связный граф называется деревом.",
			ExampleImage: "asserts/images/деревья-схема 1.png", 
			ExampleText: "Условие:\n"+
			"Дано дерево с 15 вершинами.\n"+
			"\n"+
			"Вопросы: Сколько в нём рёбер?\n"+
			"Если дерево является бинарным (каждая вершина имеет не более 2 потомков), каково максимальное количество листьев в таком дереве?\n"+
			"Как изменится количество рёбер, если добавить 3 новых вершины, сохраняя свойство дерева (связность и отсутствие циклов)?\n",
			Hint: "Основное свойство дерева:\n"+
			"Для дерева с p вершинами количество рёбер всегда равно q = p - 1.\n"+
			"\n"+
			"Листья в бинарном дереве:\n"+
			"Максимальное число листьев достигается, когда все уровни дерева заполнены, кроме, возможно, последнего.\n"+
			"\n"+
			"Добавление новых вершин:\n"+
			"Каждая новая вершина в дереве добавляет ровно одно ребро.\n",
			SolutionText: "Количество рёбер в дереве с 15 вершинами:\n"+
			"По свойству деревьев: q = p − 1 = 15 − 1 = 14 рёбер.\n"+
			"\n"+
			"Максимальное число листьев в бинарном дереве:\n"+
			"В полном бинарном дереве (все уровни заполнены) с высотой h число листьев равно 2^h.\n"+
			"Для 15 вершин:\n"+
			"Высота дерева: h = | log2 ​15| = 3.\n"+
			"На 3-ем уровне может быть до 2^3 = 8 листьев.\n"+
			"Но так как вершин всего 15, а на первых 3 уровнях уже 1 + 2 + 4 = 7 вершин, остаётся 15 − 7 = 8 вершин на 4-ом уровне.\n"+
			"Итог: Максимальное число листьев = 8 (все вершины последнего уровня).\n"+
			"\n"+
			"Добавление 3 новых вершин:\n"+
			"Изначально рёбер: 14.\n"+
			"Каждая новая вершина добавляет 1 ребро: q(новое) = 14 + 3 = 17 рёбер.\n"+
			"Проверка: p(новое) = 15 + 3 = 18, тогда q = 18 − 1 = 17 (верно).\n",
		}
	case "Алгоритм Дейкстры":
		return ProbabilityData{
			Title:  "Алгоритм Дейкстры",
			Theory: "Алгоритм Дейкстры используется для нахождения кратчайшего пути от одной вершины до всех остальных в взвешенном графе с неотрицательными весами.",
		}
		
	default:
		return ProbabilityData{
			Title:  "Ничего не найдено",
			Theory: "Теория для этой темы пока не добавлена.",
		}
	}
}
